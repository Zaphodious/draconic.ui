# User Interface

A user interface is the place where user and system meet in order that the latter assist the former. These needn't be graphical. Many powerful developer tools (including git) present a command-line interface, and the machines at many supermarkets are equipped with a panel of physical buttons and a single-line text readout visable to the cashier. Every single one of these UIs functions as a loop, taking user input, parsing it and doing something important, showing the result to the user, and then taking more user input. In this simple concept lies the real utility behind computing in general, and why these marvelous machines have become ubiquitous.

In Clojure, where our primary concerns are taking in, putting out, and manipulating data, a UI is a tool for allowing the user to participate in this process. A data-driven UI is a conceptually simple thing! Many of the more infamously messy problems associated with UI programming have to do with the way that the individual UI APIs complect layout, widget selection, and stateful data binding. If we separate out data binding, leaving layout and widget selection to either another step or another person entirely, the problem is suddenly simple and similar to the same way that Clojure already models state.

A perfect illustration of a data-driven UI is the Clojure REPL. Each REPL, regardless of platform, UI Toolkit, or back-end bindings, is the same- each one has an area into which the user writes a form as a String, an input that signals that the form is ready for evaluation, and a readout that shows the text from past evaluations and onto which the present form and result will be posted upon evaluation. Even though individual REPL implementations are incredibly complex (and powerful because of it) and each one is a bit different, the place where system meets user is uniform, mostly consistent, and differs to the end user only when additional features are added (autocomplete, help, ect). These three basic elements define a Clojure REPL, and as long as they are present then anyone familiar with Clojure can use it.

The problems with cross-platform/cross-toolkit UI building in general are that each platform/framework requires that the data model be coded into it using its own bindings, and that most domains have necessarily big data models with many separate elements. Individual elements require their own place to display or accept input, each platform has its own preferred semantics and guidelines, and users generally don't respond well to write-once UIs that *feel* "cross-platform". The way things are done currently, this means that only the data model is similar between platforms, and that binding the model to each kind of UI element is repeated per platform. For something very simple like the REPL this is fine, but as domains grow in minimum required complexity the amount of boilerplate, duplication, and effort grows tremendously with each added platform. If repeated effort, duplicated code, and complexity is bad, then this practice leaves something to be desired.

A possible solution is to use an abstraction to represent individual UI elements in their most basic possible forms, program the data model against these abstractions, and then run the binding code on each platform after the UI has been carefully designed for that platform's specific requirements. This is the intention of this library. By decomposing common UI elements into what type of data they hold and display, and then by writing the data binding on a shared library level only caring about putting data in to and getting data out of the node when required, more time can be spent on platform or data-model specific concerns resulting in a better product and a better experience. 